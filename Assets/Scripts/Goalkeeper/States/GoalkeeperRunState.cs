using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class GoalkeeperRunState : GoalkeeperState
{

    public static GoalkeeperRunState goalkeeperRunState = new GoalkeeperRunState();
    private State currentState = State.withoutBall;
    private enum State
    {
        withBall, withoutBall
    }

    public void EnterTheState(Goalkeeper goalkeeper)
    {

        if (currentState == State.withoutBall)
        {
            //Debug.Log("enter : RunningState_withoutBall");
            goalkeeper.ChangeAnimation("Run");
        }
        else
        {
            //Debug.Log("enter : RunningState_withBall");
            goalkeeper.ChangeAnimation("Run");
        }


    }

    public void ExitTheState(Goalkeeper goalkeeper)
    {

        if (currentState == State.withoutBall)
        {
            //Debug.Log("exit : RunningState_withoutBall");
        }
        else
        {
            //Debug.Log("exit : RunningState_withBall");
            // top yavaþlatýlmalý

            // topun mevcut hýz vektörü bulundu
            Vector3 currentBallVelocity = goalkeeper.Ball.Rb.velocity;
            // hedef vektör için mevcut hýz vektörüne eklenmesi gerekli olan vektör bulundu
            Vector3 addVelocityToBall = Vector3.zero - currentBallVelocity;

            // eðer eklenecek vektör sýnýrlamadan büyük ise büyüklüðü ayarlandý
            if (addVelocityToBall.magnitude > ballTargetVelocity)
            {
                addVelocityToBall = addVelocityToBall.normalized * ballTargetVelocity;

            }
            // eklenecek vektör topa eklendi
            currentBallVelocity += addVelocityToBall;
            goalkeeper.Ball.Rb.velocity = currentBallVelocity;
            //eðer top çok yavaþ ise direk hýzý 0 a eþitlenir
            if (goalkeeper.Ball.Rb.velocity.magnitude < 3f)
            {
                goalkeeper.Ball.Rb.velocity = Vector3.zero;
                goalkeeper.Ball.Rb.angularVelocity = Vector3.zero;
            }

        }

    }

    public void ExecuteTheState(Goalkeeper goalkeeper)
    {
        // Running için Runningwithball ve Runningwithoutball diye 2 state oluþturmak yerine 2 methoda böldüm
        if (goalkeeper.BallVision.IsThereBallInVision())
        {
            if (currentState != State.withBall)
            {
                currentState = State.withBall;
                EnterTheState(goalkeeper);
            }
            ExecuteWithBall(goalkeeper);
        }
        else
        {
            if (currentState != State.withoutBall)
            {
                currentState = State.withoutBall;
                EnterTheState(goalkeeper);
            }
            ExecuteWithoutBall(goalkeeper);
        }

    }

    private void ExecuteWithBall(Goalkeeper goalkeeper)
    {

        if (goalkeeper.Inputter.GetButtonShootValue() != 0&& goalkeeper.BallVision.IsThereBallInVision())
        {   //Shoot inputu var shootState e gider
            goalkeeper.ChangeCurrentState(GoalkeeperShootState.goalkeeperShootState);
        }
        else if (goalkeeper.Inputter.GetJoyStickVerticalValue() == 0
            && goalkeeper.Inputter.GetJoyStickHorizontalValue() == 0)
        {
            // input olmadýðý için IdleState gider
            goalkeeper.ChangeCurrentState(GoalkeeperIdleState.goalkeeperIdleState);

        }

        //RunningState in iþlemleri yapýlýr
        RunWithBall(goalkeeper);


    }


    private void ExecuteWithoutBall(Goalkeeper goalkeeper)
    {

        if (goalkeeper.Inputter.GetButtonJumpValue() != 0)
        {   //Jump inputu var jumpState e gider
            goalkeeper.ChangeCurrentState(GoalkeeperJumpState.goalkeeperJumpState);
        }
        else if (goalkeeper.Inputter.GetJoyStickVerticalValue() == 0
            && goalkeeper.Inputter.GetJoyStickHorizontalValue() == 0)
        {
            // input olmadýðý için IdleState gider
            goalkeeper.ChangeCurrentState(GoalkeeperIdleState.goalkeeperIdleState);

        }

        //RunningState in iþlemleri yapýlýr
        Run(goalkeeper);




    }



    private float gap = 2f;        //  küçük açý farklarý görmezden gelinir
    private float spinSpeed = 500f; //  rotation deðiþim hýzý
    private void Run(Goalkeeper goalkeeper)
    {

        float inputVertical = -goalkeeper.Inputter.GetJoyStickVerticalValue();
        float inputHorizontal = goalkeeper.Inputter.GetJoyStickHorizontalValue();

        // inputa göre x ve z eksenindeki hedef Forward vektörü bulundu 
        //Vector2 targetForward = new Vector2(inputVertical, inputHorizontal).normalized;
        // Rotation ayarlanmasý için spin methoduna gidilir
        //Spin(goalkeeper, targetForward);



        // y olmadan birim forward vektörü bulundu
        Vector3 directionVector
            = new Vector3(inputVertical, 0, inputHorizontal).normalized;

        directionVector *= goalkeeper.MovementSpeed;    // hýz vektörü oluþturuldu

        directionVector.y = goalkeeper.Rb.velocity.y;   // y'nin deðiþmesini istemiyorum

        goalkeeper.Rb.velocity = directionVector;       // goalkeeperýn hýzý ayarlandý





    }


    private float ballTargetVelocity = 15.5f;

    private float trackingToBallSpeed = 13f;

    private float minDistanceWithBall = 1.8f;

    private float ballMaxAddVelocity = 5.2f;

    private float minDistanceToAddVelocityToBall = 2f; // minDistanceWithBall dan büyük olmalý


    private Vector3 lastBallForward;
    private void RunWithBall(Goalkeeper goalkeeper)
    {

        float inputVertical = -goalkeeper.Inputter.GetJoyStickVerticalValue();
        float inputHorizontal = goalkeeper.Inputter.GetJoyStickHorizontalValue();

        // topla goalkeeper arasýndaki mesafe bulundu
        float distanceWithBall = Vector3.Distance(goalkeeper.transform.position, goalkeeper.Ball.transform.position);

        //-----top takip ediliyor

        //  takip etmek için gerekli birim vektör bulundu
        Vector3 ballForwardVector = (goalkeeper.Ball.transform.position - goalkeeper.transform.position).normalized;

        // topun konumuna rotation ayarlanýyor
        Spin(goalkeeper, new Vector3(ballForwardVector.x, ballForwardVector.z).normalized);

        Vector3 forwardVectorWithoutY
            = new Vector3(goalkeeper.transform.forward.x, 0, goalkeeper.transform.forward.z).normalized;

        float trackingSpeed = trackingToBallSpeed;
        // takip hýzýnýn top ile aradaki mesafe ile linear olmasý saðlanýyor
        trackingSpeed *= (distanceWithBall - minDistanceWithBall) * 5;
        trackingSpeed = Mathf.Clamp(trackingSpeed, 0, trackingToBallSpeed);// limiti geçmesini istemiyoruz

        forwardVectorWithoutY *= trackingSpeed;           // hýz vektörü oluþturuldu
        forwardVectorWithoutY.y = goalkeeper.Rb.velocity.y;   // y nin sabit kalmasýný istiyorum
        goalkeeper.Rb.velocity = forwardVectorWithoutY;       // hýz ayarlandý

        //-----


        //----topa hýz veriliyor


        //targetDirection = DirectionHelper.FindDirection(inputVertical, inputHorizontal);
        Vector3 ballTargetForwardVector = new Vector3(inputVertical, 0, inputHorizontal).normalized;


        float angle = Vector3.SignedAngle(ballForwardVector, ballTargetForwardVector, Vector3.up);
        if (Mathf.Abs(angle) > 160f)
        {
            //Debug.Log(((int)Vector3.SignedAngle(ballForwardVector, ballTargetForwardVector, Vector3.up)));
            ballTargetForwardVector = Quaternion.AngleAxis(-90, Vector3.up) * ballTargetForwardVector;
        }


        bool needChangeVelocity;
        // yön deðiþimi oldu ise oyun tepki vermeli akýcýlýk için
        bool changeDirection = Vector3.Angle(ballTargetForwardVector, lastBallForward) > 40f;
        // top hýz verecek kadar yakýn mý ?
        needChangeVelocity = (distanceWithBall <= minDistanceToAddVelocityToBall) || changeDirection;

        if (needChangeVelocity)
        {

            // top için hedef hýzýn vektörü bulundu 
            Vector3 targetBallVelocity
                = ballTargetVelocity * (changeDirection ? 0.8f : 1) * ballTargetForwardVector;
            // topun mevcut hýz vektörü bulundu
            Vector3 currentBallVelocity = goalkeeper.Ball.Rb.velocity;
            // hedef vektör için mevcut hýz vektörüne eklenmesi gerekli olan vektör bulundu
            Vector3 addVelocityToBall = targetBallVelocity - currentBallVelocity;
            // eðer eklenecek vektör sýnýrlamadan büyük ise büyüklüðü ayarlandý
            addVelocityToBall = Vector3.ClampMagnitude(addVelocityToBall, ballMaxAddVelocity);

            // eklenecek vektör topa eklendi
            currentBallVelocity += addVelocityToBall;
            goalkeeper.Ball.Rb.velocity = currentBallVelocity;

            lastBallForward = ballTargetForwardVector;

        }


    }

    private void Spin(Goalkeeper goalkeeper, Vector2 targetForward)
    {

        //  dönme x ve z eksenine göre y de yapýlýyor bu yüzden 2 boyutlu bir iþlem
        //  kuþ bakýþý yapýlýyor olarak düþünülebilir

        // x ve z eksenindeki mevcut Forward vektörü bulundu
        Vector2 curretForward = new Vector2(goalkeeper.transform.forward.x, goalkeeper.transform.forward.z);

        //  aradaki açý bulundu
        float angleBetweenVectors = Vector2.SignedAngle(curretForward, targetForward);

        // aradaki açý küçük deðil ise iþlem yapýlýr
        if (Mathf.Abs(angleBetweenVectors) > gap)
        {
            //-- dönme yönüne göre goalkeeperýn eulerAnglesý spinSpeed*Time.deltaTime kadar deðiþtirildi
            Vector3 eulerAng = goalkeeper.transform.eulerAngles;
            eulerAng.y += spinSpeed * Time.deltaTime * ((angleBetweenVectors < 0) ? +1 : -1);
            goalkeeper.transform.eulerAngles = eulerAng;
            //---

        }

    }


}
